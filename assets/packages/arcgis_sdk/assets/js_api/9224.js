"use strict";(self.webpackChunkarcgis_node=self.webpackChunkarcgis_node||[]).push([[9224],{69224:(e,t,r)=>{r.r(t),r.d(t,{BufferObject:()=>n.g,FramebufferObject:()=>s.H,Program:()=>o.B,ProgramCache:()=>a.J,Renderbuffer:()=>i.l,ShaderCompiler:()=>c.Z,Texture:()=>f.g,VertexArrayObject:()=>l.Z,createContext:()=>h.q,createProgram:()=>u.r,glslifyDefineMap:()=>d.I});var n=r(89325),s=r(49214),o=r(19980),a=r(25762),i=r(53386),c=r(27824),f=r(89958),l=r(40866),d=r(70645),u=r(16284),h=r(46480)},16284:(e,t,r)=>{r.d(t,{r:()=>s});var n=r(19980);function s(e,t,r=""){return new n.B(e,r+t.shaders.vertexShader,r+t.shaders.fragmentShader,t.attributes)}},27824:(e,t,r)=>{r.d(t,{Z:()=>n});class n{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e,t=new Map){if(t.has(e))return t.get(e);const r=this._read(e);if(!r)throw new Error(`cannot find shader file ${e}`);const n=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let s=n.exec(r);const o=[];for(;null!=s;)o.push({path:s[1],start:s.index,length:s[0].length}),s=n.exec(r);let a=0,i="";return o.forEach((e=>{i+=r.slice(a,e.start),i+=t.has(e.path)?"":this._resolve(e.path,t),a=e.start+e.length})),i+=r.slice(a),t.set(e,i),i}_read(e){return this._readFile(e)}}},70645:(e,t,r)=>{function n(e){const{options:t,value:r}=e;return"number"==typeof t[r]}function s(e){let t="";for(const r in e){const s=e[r];if("boolean"==typeof s)s&&(t+=`#define ${r}\n`);else if("number"==typeof s)t+=`#define ${r} ${s.toFixed()}\n`;else if("object"==typeof s)if(n(s)){const{value:e,options:n,namespace:o}=s,a=o?`${o}_`:"";for(const e in n)t+=`#define ${a}${e} ${n[e].toFixed()}\n`;t+=`#define ${r} ${a}${e}\n`}else{const e=s.options;let n=0;for(const r in e)t+=`#define ${e[r]} ${(n++).toFixed()}\n`;t+=`#define ${r} ${e[s.value]}\n`}}return t}r.d(t,{I:()=>s})}}]);